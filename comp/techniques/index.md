[トップ](../../) > [競技プログラミング](../) > テクニック

# テクニック集

このページでは、競プロをするときに知っておくと役にたつテクニックや知識を紹介します。

だいたい難易度順になっているのではないかと思います。

(著者はこの記事の執筆時点ではAtCoderで灰色、つまり最低ランクなのであまり高レベルなことは解説できません。すみません...)

## 目次

- [初級編](#初級編)
  - [数学系の関数](#数学系の関数)
  - [vector](#vector)
  - [二重配列](#二重配列)
  - [ソート](#ソート)
  - [set](#set)
  - [map](#map)
- [中級編](#中級編)
  - [repマクロ](#repマクロ)
  - [long long](#long-long)
  - [全探索](#全探索)
  - [貪欲法](#貪欲法)
  - [計算量](#計算量)
- [上級編](#上級編)
  - [ACL](#acl)
  - [MOD](#mod)
  - [グラフ](#グラフ)
- [発展編](#発展編)
  - [深さ優先探索(DFS)](#深さ優先探索dfs)
  - [幅優先探索(BFS)](#幅優先探索bfs)
  - [Union-Find](#union-find)

<h2 id="初級編">初級編</h2>

<h3 id="数学系の関数">数学系の関数</h3>

```cpp
sin(x), cos(x), tan(x)      // 三角関数 xの単位はrad
exp(x)                      // eのx乗
log(x), log10(x)            // 底がeや10の対数
pow(x, y)                   // xのy乗
sqrt(x)                     // √x 平方根=square root
ceil(x), round(x), floor(x) // 切り上げ・切り捨て
```

すべて引数・返り値は`double`型です。

これらの関数は(`stdc++.h`をincludeしていれば)いつでも使えるので、覚えておくと便利です。忘れても調べたらすぐ出てきますが、「こんな関数あったな」ということだけは覚えておきましょう。

整数だけでなく`double`型の値に対しても実行できるのがポイントです。

<h3 id="vector">vector</h3>

```cpp
vector<int> vec1;       // 中身の型がint、長さ0のvectorを作成
vector<int> vec2(n);    // 長さnと指定しておくこともできます(勝手に0などをセットしてくれる)
vector<int> vec3(n, 1); // 初期値の指定も可能です(長さn、中身がすべて1のvectorができる)
vector<string> vec4(n); // 中身の型はなんでも良い
```

ベクトルという名前なので身構えてしまうかもしれませんが、使いやすい配列だと思ってもらって大丈夫です。他の言語だと`List<T>`などと呼ばれているかもしれません。

Cの配列を使ってもプログラムを書くことはできますが、vectorでは長さの取得(`vec.size()`)、中身のクリア(`vec.clear()`)、最後尾への追加(`vec.push_back(x)`)などいろいろな関数が使えるようになっています。

もちろん、i番のデータ(iは0始まり)のデータは`vec[i]`で取得できます。わかりやすいですね。

問題文で「長さNの数列Aがあります」とある場合、

```cpp
int n;
cin >> n;
vector<int> a(n);
for(int i=0; i<n; ++i) {
  cin >> a[i];
}
```

と書くことでAをすべて取得してvectorに入れることができます。

<h3 id="二重配列">二重配列</h3>

`vector<T>`のTの部分はなんでも良いと言いましたが、ここにvectorを入れることで二次元平面を表すことができます。

問題文で「高さH、幅W、各マスは文字で`.`か`#`」とある場合、

```cpp
int h, w;
cin >> h >> w;

// stage[i][j]で「ステージの上からi、左からjのマス」を取得できる、という感じにする
// ↑ただしi、jは0始まり
// stage[i]で「上からiのところの1行」が取得できると考えるとわかりやすいかも?
vector<vector<string>> stage(h, vector<string>(w));
for(int i=0; i<h; ++i) {
  for(int j=0; j<w; ++j) {
    cin >> stage[i][j];
  }
}
```

<h3 id="ソート">ソート</h3>

vectorをソートしてくれる関数がすでにあるので、それを使います。

```cpp
vector<int> vec({1,4,2,6,7,3,7,9,2});
sort(vec.begin(), vec.end());
```

`vec.begin()`、`vec.end()`はイテレータです。これはメモリアドレス(ポインタ)のようなものだと思ってください。
イテレータに対して足し算や引き算もできますが、あまり使う場面はないかと思います。

<h3 id="set">set</h3>

重なりがなく、順番になっているvectorだと思ってください。
今は何に使うかわからないかもしれませんが、他のテクニックで時々出てきます。

```cpp
set<int> s;
s.insert(1); // 1を追加
s.insert(2); // 2を追加
s.erase(1);  // 1を削除
```

<h3 id="map">map</h3>

vectorは「index番号(数字)」から値が得られるようになっていましたが、mapを使えば数字以外を使うことができます。

辞書が「見出し語(string)」から「説明(string)」を得られるのと同じような感じなので、言語によっては`Dictionary<K, V>`などと呼ばれているかもしれません。

```cpp
// 名前:得点 を想定
// 一つ目の、データを引き出すのに使う方の値をKey、2つ目の、中身のデータをValueと呼びます
// 今回の場合はKeyがstring、Valueがintですね
map<string, int> scores;

scores["太郎"]++;               // 太郎が得点を得た
scores["花子"] = 100;           // 花子の得点を100にした
cout << scores["太郎"] << endl; // 太郎の得点を出力
// -> 「1」と出力される
```

<h2 id="中級編">中級編</h2>

この辺りから競プロ独特の感じが出てきます。

<h3 id="repマクロ">repマクロ</h3>

`for(int i=0; i<n; ++i)`と書くのが面倒くさいと思った時に役にたつものです。

コードの好きな場所(`using namespace`の後がおすすめ)に以下のコードを書いてください。

```cpp
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
```

このコードは、`rep(i, n)`と書いた時、`for (int i = 0; i < (int)(n); i++)`に変換してくれるというものです。

これを使うと、例えば[二重配列](#二重配列)で解説したコードが次のようにかけます。

```cpp
int h, w;
cin >> h >> w;
vector<vector<string>> stage(h, vector<string>(w));
rep(i, h) rep(j, w) {
  cin >> stage[i][j];
}
```

見やすくなったと感じた場合はぜひ使ってみてください。

<h3 id="long-long">long long</h3>

今まで整数を表すのに使ってきた`int`は、実は-20億から20億程度の範囲しか表すことができません。

(厳密には`-2147483648`から`2147483647`、0を含めれば2^32通りの数を表せます。)

問題によってはこれを超える数が出てくる場合があります。その場合は、超えそうな部分の`int`を`long long`に変えてください。

`long long`は、約±(10^19)ほどの値を保存することができます。

(厳密には`-9223372036854775808`から`9223372036854775807`、0を含めれば2^64通りの数を表せます。)

これで足りないことはまずないです。もしどうしても足りないとなれば、おそらく[MOD](#MOD)を使うことを想定された問題です。

<h3 id="全探索">全探索</h3>

問題を解く上で、困ったらとりあえず全探索を考えてみましょう。

例えば何かの最大値を求めたいとき、すべての可能性を考えれば必ず答えは出るはずです。

もちろん、あまりにも計算回数が多ければ制限時間に間に合いません。[計算量](#計算量)を参照してください。

<h3 id="貪欲法">貪欲法</h3>

まだ書いてない

<h3 id="計算量">計算量</h3>

まず前提として、パソコンが1秒に実行できる計算はおよそ10^8回です。

なので、自分のプログラムのループ回数を数え、もし10^10などであれば間に合わないと予測することができます。

計算回数は、よく「オーダー記法」というものが使われます。知っておいて損はないでしょう。

例えば、要素がN個ある時に、`N^2 + 5xN + 10`回の計算をしなければならない場合、これは`O(N^2 + 5xN + 10)`と書ける...はずなのですが、Nがとても大きい、最も時間がかかる場合を考えるので、Nの最高次数の項だけを残します。つまり、この場合は`O(N^2)`と書けます。

この場合、N<=500などなら間に合いそうですが、N<=10^5などなら間に合わないだろうということがわかります。

<h2 id="上級編">上級編</h2>

<h3 id="acl">ACL</h3>

AtCoder社が作ったC++用ライブラリです。[公式配布ページ](https://atcoder.jp/posts/517)

[ドキュメント](https://atcoder.github.io/ac-library/master/document_ja/)を見てもらえれば書いてあるので、細かい説明は省きます。

普通に実装するのは大変な機能を、ただ呼び出すだけで使うことができるのでぜひ活用してください。

AtCoderのC++の提出では、以下を書くことで使用できます。

```cpp
#include <bits/stdc++.h>; // 元からある
#include <atcoder/all>;

using namespace std;      // 元からある
using namespace atcoder;
```

自分のパソコンでの実行は少し大変です。またどこかで解説しようと思います。

<h3 id="mod">MOD</h3>

たまに「998244353で割った余り」などを要求される問題があります。
これは答えが非常に大きくなり、実際の値を計算することが非常に難しいことを表しています。

計算ごとに合同式の考え方を用いて数字を減らしていけば大丈夫です。ただし、いちいちそんなことをするのは面倒くさいので、[ACL](#acl)の`modint`を利用しましょう。

`int`の代わりに`modint998244353`(条件によっては`modint1000000007`)を使うだけです。

<h3 id="グラフ">グラフ</h3>

ここでのグラフは、よく見かけるような折れ線グラフなどではなく、「頂点」同士を「辺」で繋いだ構造のことです。[グラフ理論](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%95%E7%90%86%E8%AB%96)、[グラフ(データ構造)](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%95_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0))などの解説が参考になるかもしれません。

つまり、下の図のような構造のことです。(これは無向グラフと呼ばれます)

![グラフの例](https://upload.wikimedia.org/wikipedia/commons/5/5b/6n-graf.svg)

グラフ理論はさまざまな人により研究され、多くの定理が確立しています。
なので、問題をうまくグラフに落とし込むことさえできれば、あとはグラフ理論の資産を使って解くことができる場合が多いです。

これから解説する[深さ優先探索(DFS)](#深さ優先探索dfs)、[幅優先探索(BFS)](#幅優先探索bfs)などを使えるようになれば、より効率的なプログラムを組むことができるようになります。

<h2 id="発展編">発展編</h2>

<h3 id="深さ優先探索dfs">深さ優先探索(DFS)</h3>

DFSは、[グラフ](#グラフ)を効率よく全探索する方法です。
例えば、下のグラフを見てください。

![グラフの例](https://upload.wikimedia.org/wikipedia/commons/5/5d/Depth-first-tree.png)

> [Wikipedia](https://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2)より引用 *CC 表示-継承 3.0*

で、「1から5へは辿り着けるか?」と聞かれたら、迷わず「はい」と答えるでしょう。
多くの人は見た目で解いたとは思いますが、コンピューターはそれができません。

深さ優先探索では、グラフ上で1手で行けるところだけを考え、それに隣接しているところをまた考え...と繰り返すことで、全部の点を探索しようとするものです。

「迷路で、スタートからずっと右(左)の壁に沿って歩けばゴールにつける」ということを聞いたことがありますか? それとどこか似ている方法です。

実際に考えてみます。ルールは以下の2つです。

1. 隣接している頂点のうち、まだ行ったことのなく、最も数字が大きいものへ移動する
2. 行き止まりになったら、少しずつ戻りながら1.を満たす頂点に移動する

まず初めに1にいるとします。隣接頂点は2、7、8のため、8へ移動します。隣接頂点を考えます。1、9、12ですが、1はさっき訪れたので9、12です。12へ移動し隣接頂点を見てみると、移動できるところがありません。少し戻り、9へ移動します。10、11と隣接しているため、11へ移動します。行き止まりなので戻ります....

このようになるはずです。実際に探索される順番は以下の通りです。

```
(開始) 1 8 12 9 11 10 7 2 6 3 5 4 (終了)
```

しっかりと全ての点を探索できていますね。

これを実装してみます。C++での実装においては、ほとんどの場合`stack`というものが使われます。
stackとは、床に積んだ本に例えられることが多いです。「上に積む」「一番上を取り除く」の2つの操作しかできないリストです。

これをtodoリスト、つまり「繋がっているのはわかっているけれど、その先はまだ見れていない」もののリストとして使います。

このほかに、「すでに訪れた頂点」を入れておくリスト、seenも作ります。setという「重複も順序もないvector」のようなものを使うことで、うまく作ることができます。

頂点1と頂点aが繋がっているかを判定するコードは、例えば以下のように書けるはずです。

```cpp
#include <bits/stdc++.h>

int main() {
  // graph[i] に「頂点iと直接繋がっている頂点のidのset」を入れておきます
  // グラフの形はサイト上の画像の通りですが、0始まりにするため全ての頂点から1を引いています
  // 一度紙に書いてみることをお勧めします
  vector<set<int>> graph = {
    {1, 6, 7},
    {0, 2, 5},
    {1, 3, 4},
    {2},
    {2},
    {1},
    {0},
    {0, 8, 11},
    {7, 9, 10},
    {8},
    {8},
    {7}
  }

  int a;
  cin >> a;

  // todoリスト、最初は0から始める
  stack<int> todo = {0};
  // 訪問済リスト、0は最初から訪問済
  set<int> seen = {0};

  // todoリストが空になるまで繰り返す
  while(todo.size() > 0) {
    // 一つ取り出す(topを見る→topを捨てる)
    int target = todo.top(); todo.pop();
    for(int child : graph[target]) {
      if(seen.count(child) != 0) continue;

      /*
      もちろん、ここで「child == a か?」と判定を行っても問題ありません。
      そのほうがループを早く抜けられ、早いかもしれません。
      ただ、競プロのテストコードは最も時間のかかるのものを選んでくるため、あまり効果がないことが多いです。
      競プロ以外の業務などのコードでは、ここに書くメリットはより大きくなるでしょう。
      ループの早期脱出とif文の重さ、どちらを取るかです。試してみて早い方を使いましょう。
      */

      seen.push(child);
      todo.puah(child);
    }
  }


  if(seen.count(a)) cout << "Yes" << endl;
  else cout << "No" << endl;
}
```

<h3 id="幅優先探索bfs">幅優先探索(BFS)</h3>

BFSは、DFSととても似た方法です。コードも、できることもほとんど同じです。

先ほども使ったグラフをもう一度掲載します。

![グラフの例](https://upload.wikimedia.org/wikipedia/commons/5/5d/Depth-first-tree.png)

> [Wikipedia](https://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2)より引用 *CC 表示-継承 3.0*

幅優先探索では、名前の通り「深さ」ではなく「幅」を先に探索します。幅とはなんだ、という感じですが、つまりは近いところから探索していく、ということになります。

このようなルールに基づいて探索してみます。

1. 隣接している頂点のうち、まだ行ったことのないものを全て記録しておく
2. 記録した頂点を順に探索し、1.の操作を繰り返す

このように探索すれば、以下のような順番で頂点を回ることができるはずです。

```
(開始) 1 2 7 8 3 6 9 12 4 5 10 11 (終了)
```

スタートした頂点から近い順に探索できていることがわかると思います。

この方法では、「距離1で行ける頂点」「距離2で行ける頂点」と順に探索できます。これによって、迷路などの最短経路、ゲームの最短手数などを求めることができます。

コードはこうなります。DFSの`stack`が`queue`(先入先出、イベントの待ち列のような感じ)に、`todo.top()`が`todo.front()`に変わっただけです。

```cpp
#include <bits/stdc++.h>

int main() {
  vector<set<int>> graph = {
    {1, 6, 7},
    {0, 2, 5},
    {1, 3, 4},
    {2},
    {2},
    {1},
    {0},
    {0, 8, 11},
    {7, 9, 10},
    {8},
    {8},
    {7}
  }
  int a;
  cin >> a;
  // 変更点1: stackをqueueに変更
  queue<int> todo = {0};
  set<int> seen = {0};
  while(todo.size() > 0) {
    // 変更点1: topをfrontに変更
    int target = todo.front(); todo.pop();
    for(int child : graph[target]) {
      if(seen.count(child) != 0) continue;
      seen.push(child);
      todo.puah(child);
    }
  }
  if(seen.count(a)) cout << "Yes" << endl;
  else cout << "No" << endl;
}
```

では、深さ優先探索と幅優先探索はどう使い分ければいいのでしょうか?

どちらも全探索なので速度に大きな違いはないです。幅優先探索では、頂点に辿り着いた時点で「最短経路」が分かるので、その時点で探索を終了することができます。よって、大体の場合は幅優先探索を使っておけば良いです。

(深さ優先探索は省メモリなので、メモリ制限がきつい場合はこちらを使ってください)

<h3 id="union-find">Union-Find</h3>

まだ書いてない
