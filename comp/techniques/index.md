[トップ](../../) > [競技プログラミング](../) > テクニック

# テクニック集

このページでは、競プロをするときに知っておくと役にたつテクニックや知識を紹介します。

だいたい難易度順になっているのではないかと思います。

(著者はこの記事の執筆時点ではAtCoderで灰色、つまり最低ランクなのであまり高レベルなことは解説できません。すみません...)

## 初級編

### 数学系の関数

```cpp
sin(x), cos(x), tan(x)      // 三角関数 xの単位はrad
exp(x)                      // eのx乗
log(x), log10(x)            // 底がeや10の対数
pow(x, y)                   // xのy乗
sqrt(x)                     // √x 平方根=square root
ceil(x), round(x), floor(x) // 切り上げ・切り捨て
```

すべて引数・返り値は`double`型です。

これらの関数は(`stdc++.h`をincludeしていれば)いつでも使えるので、覚えておくと便利です。忘れても調べたらすぐ出てきますが、「こんな関数あったな」ということだけは覚えておきましょう。

整数だけでなく`double`型の値に対しても実行できるのがポイントです。

### vector

```cpp
vector<int> vec1;       // 中身の型がint、長さ0のvectorを作成
vector<int> vec2(n);    // 長さnと指定しておくこともできます(勝手に0などをセットしてくれる)
vector<int> vec3(n, 1); // 初期値の指定も可能です(長さn、中身がすべて1のvectorができる)
vector<string> vec4(n); // 中身の型はなんでも良い
```

ベクトルという名前なので身構えてしまうかもしれませんが、使いやすい配列だと思ってもらって大丈夫です。他の言語だと`List<T>`などと呼ばれているかもしれません。

Cの配列を使ってもプログラムを書くことはできますが、vectorでは長さの取得(`vec.size()`)、中身のクリア(`vec.clear()`)、最後尾への追加(`vec.push_back(x)`)などいろいろな関数が使えるようになっています。

もちろん、i番のデータ(iは0始まり)のデータは`vec[i]`で取得できます。わかりやすいですね。

問題文で「長さNの数列Aがあります」とある場合、

```cpp
int n;
cin >> n;
vector<int> a(n);
for(int i=0; i<n; ++i) {
    cin >> a[i];
}
```

と書くことでAをすべて取得してvectorに入れることができます。

### 二重配列

`vector<T>`のTの部分はなんでも良いと言いましたが、ここにvectorを入れることで二次元平面を表すことができます。

問題文で「高さH、幅W、各マスは文字で`.`か`#`」とある場合、

```cpp
int h, w;
cin >> h >> w;

// stage[i][j]で「ステージの上からi、左からjのマス」を取得できる、という感じにする
// ↑ただしi、jは0始まり
// stage[i]で「上からiのところの1行」が取得できると考えるとわかりやすいかも?
vector<vector<string>> stage(h, vector<string>(w));
for(int i=0; i<h; ++i) {
    for(int j=0; j<w; ++j) {
        cin >> stage[i][j];
    }
}
```

### ソート

vectorをソートしてくれる関数がすでにあるので、それを使います。

```cpp
vector<int> vec({1,4,2,6,7,3,7,9,2});
sort(vec.begin(), vec.end());
```

`vec.begin()`、`vec.end()`はイテレータです。これはメモリアドレス(ポインタ)のようなものだと思ってください。
イテレータに対して足し算や引き算もできますが、あまり使う場面はないかと思います。

### set

重なりがなく、順番になっているvectorだと思ってください。
今は何に使うかわからないかもしれませんが、他のテクニックで時々出てきます。

```cpp
set<int> s;
s.insert(1); // 1を追加
s.insert(2); // 2を追加
s.erase(1);  // 1を削除
```

### map

vectorは「index番号(数字)」から値が得られるようになっていましたが、mapを使えば数字以外を使うことができます。

辞書が「見出し語(string)」から「説明(string)」を得られるのと同じような感じなので、言語によっては`Dictionary<K, V>`などと呼ばれているかもしれません。

```cpp
// 名前:得点 を想定
// 一つ目の、データを引き出すのに使う方の値をKey、2つ目の、中身のデータをValueと呼びます
// 今回の場合はKeyがstring、Valueがintですね
map<string, int> scores;

scores["太郎"]++;               // 太郎が得点を得た
scores["花子"] = 100;           // 花子の得点を100にした
cout << scores["太郎"] << endl; // 太郎の得点を出力
// -> 「1」と出力される
```

## 中級編

この辺りから競プロ独特の感じが出てきます。

### repマクロ

`for(int i=0; i<n; ++i)`と書くのが面倒くさいと思った時に役にたつものです。

コードの好きな場所(`using namespace`の後がおすすめ)に以下のコードを書いてください。

```cpp
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
```

このコードは、`rep(i, n)`と書いた時、`for (int i = 0; i < (int)(n); i++)`に変換してくれるというものです。

これを使うと、例えば[二重配列](#二重配列)で解説したコードが次のようにかけます。

```cpp
int h, w;
cin >> h >> w;
vector<vector<string>> stage(h, vector<string>(w));
rep(i, h) rep(j, w) {
    cin >> stage[i][j];
}
```

見やすくなったと感じた場合はぜひ使ってみてください。

## long long

今まで整数を表すのに使ってきた`int`は、実は-20億から20億程度の範囲しか表すことができません。

(厳密には`-2147483648`から`2147483647`、0を含めれば2^32通りの数を表せます。)

問題によってはこれを超える数が出てくる場合があります。その場合は、超えそうな部分の`int`を`long long`に変えてください。

`long long`は、約±(10^19)ほどの値を保存することができます。

(厳密には`-9223372036854775808`から`9223372036854775807`、0を含めれば2^64通りの数を表せます。)

これで足りないことはまずないです。もしどうしても足りないとなれば、おそらく[MOD](#MOD)を使うことを想定された問題です。

### 全探索

問題を解く上で、困ったらとりあえず全探索を考えてみましょう。

例えば何かの最大値を求めたいとき、すべての可能性を考えれば必ず答えは出るはずです。

もちろん、あまりにも計算回数が多ければ制限時間に間に合いません。[計算量](#計算量)を参照してください。

### 計算量

まず前提として、パソコンが1秒に実行できる計算はおよそ10^8回です。

なので、自分のプログラムのループ回数を数え、もし10^10などであれば間に合わないと予測することができます。

計算回数は、よく「オーダー記法」というものが使われます。知っておいて損はないでしょう。

例えば、要素がN個ある時に、`N^2 + 5xN + 10`回の計算をしなければならない場合、これは`O(N^2 + 5xN + 10)`と書ける...はずなのですが、Nがとても大きい、最も時間がかかる場合を考えるので、Nの最高次数の項だけを残します。つまり、この場合は`O(N^2)`と書けます。

この場合、N<=500などなら間に合いそうですが、N<=10^5などなら間に合わないだろうということがわかります。

## 上級編

### ACL

AtCoder社が作ったC++用ライブラリです。[公式配布ページ](https://atcoder.jp/posts/517)

[ドキュメント](https://atcoder.github.io/ac-library/master/document_ja/)を見てもらえれば書いてあるので、細かい説明は省きます。

普通に実装するのは大変な機能を、ただ呼び出すだけで使うことができるのでぜひ活用してください。

AtCoderのC++の提出では、以下を書くことで使用できます。

```cpp
#include <bits/stdc++.h>; // 元からある
#include <atcoder/all>;

using namespace std;      // 元からある
using namespace atcoder;
```

自分のパソコンでの実行は少し大変です。またどこかで解説しようと思います。

### MOD

たまに「998244353で割った余り」などを要求される問題があります。
これは答えが非常に大きくなり、実際の値を計算することが非常に難しいことを表しています。

計算ごとに合同式の考え方を用いて数字を減らしていけば大丈夫です。ただし、いちいちそんなことをするのは面倒くさいので、[ACL](#acl)の`modint`を利用しましょう。

`int`の代わりに`modint998244353`(条件によっては`modint1000000007`)を使うだけです。

### グラフ

ここでのグラフは、よく見かけるような折れ線グラフなどではなく、「頂点」同士を「辺」で繋いだ構造のことです。[グラフ理論](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%95%E7%90%86%E8%AB%96)、[グラフ(データ構造)](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%95_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0))などの解説が参考になるかもしれません。

グラフ理論はさまざまな人により研究され、多くの定理が確立しています。
なので、問題をうまくグラフに落とし込むことさえできれば、あとはグラフ理論の資産を使って解くことができる場合が多いです。

これから解説する[深さ優先探索(DFS)](#深さ優先探索dfs)、[幅優先探索(BFS)](#幅優先探索bfs)などを使えるようになれば、より効率的なプログラムを組むことができるようになります。

## 発展編

### 深さ優先探索(DFS)

### 幅優先探索(BFS)
